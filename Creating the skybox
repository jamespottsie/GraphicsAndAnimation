//Create scene, camera, renderer within an init function to initialize Three.js
let scene, camera, renderer, skyboxGeo, skybox;

function init(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(
    55,
    window.innerWidth / window.innerHeight,
    45,
    30000
    );
    camera.position.set(1200, -250, 20000);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.id = "canvas";
    document.body.appendChild(renderer.domElement);
    animate();
}
function animate(){
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

init();

//Create a box with THREE.BoxGeometry, then use THREE.Meesh to apply a texture.
function init(){

skyboxGeo = new THREE.BoxGeometry(10000, 10000, 10000); 
skybox = new THREE.Mesh(skyboxGeo);

//Add the object to the scene before calling the animate function with the init function.
scene.add(skybox);
}

animate();

//Create a rotation animation within the animate function.
function animate (){
    skybox.rotation.x += 0.005;
    skybox.rotation.y += 0.005;
    renderer.render(scene, camera);
    requestAnimationFrame(animate);

}

//Create an reusable function that loops through all the images
// The function createPathStrings() will create an array of path strings from the file image name.

function createPathStrings(daylightbox_pieces) {
const basePath ="./static/skybox/";
const fileType = ".jpg";
const sides = ["ft", "bk", "up", "dn", "rt", "lf"];
const pathStrings = sides.map(side=> {
    return basedaylightbox_pieces + "_" + side + jpg;
});
return pathStrings;
}

['./static/skybox/daylightbox_ft.jpg', './static/skybox/daylightbox_bk', './static/skybox/daylight_up.jpg', './static/skybox/daylight_dn', './static/skybox/daylight_rt','./static/skybox/daylight_lf']

//Load each texture using TextureLoader().load() by mapping over the array above.
//The function createMaterialArray() will generate a new array of loaded textures.
let skyboxImage = "daylightbox_pieces";
function createMaterialArray(daylightbox_pieces){
    const skyboxImagePaths = createPathStrings(daylightbox_pieces);
    const materialArray = skyboxImagepaths.map(image => {
        let texture = new THREE.TextureLoader().load(image);

        return new THREE.MeshBasicMaterial({map: texture, side: THREE.Backside});
    });
    return materialArray;
}

//Ready to add mesh array to the cube created above.
const skyboxImage = 'daylightbox_pieces';
function init(){
    ...
    const materialArray = createMaterialArray(skyboxImage);
    skyboxGeo = new THREE.BoxGeometry(10000, 10000, 10000);
    skybox = new THREE.Mesh(skyboxGeo, materialArray);
    scene.add(skybox);
    animate();
}

//Change the camera's z position from 20000 to 2000 to putthe camera inside the cube.
function init()
...
camera.position.set(1200, -250, 2000);
...
}

//Create a variable named controls to the initialization at the top
let scene , camera, renderer, skyboxGeo, skybox, controls;
function init(){
    ...
// Assign controls to the OrbitControls method while passing in the camera and domElement.
//Enable the controls by setting controls.enabled to true.
//set the min/max distance so that the user cannot zoom outside the cube.
    controls= new Three.OrbitControls(camera, renderer, domElement);
    controls.enabled = true;
    controls.minDistance = 700;
    controls.maxDistance = 1500;

    ...
    animate();
}

//Remove the rotation in the animate() function and add controls.update();
function animate () {
    controls.update ();
    renderer.render(scene, camera);
    requestAnimationFrame(animate;)
}

//This will allow the user to click and drag the environment to see whatever part they want.

function init () {
    ...
    controls = new THREE.OrbitControls (camera, renderer. domElement);
    controls.enabled =true;
    controls.minDistance = 700;
    controls.maxDistance = 1500;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.0;

    ...
    animate();
}

//Create a function to redefine the camera.aspect and renderer size to the height and width of the window.

function onWindowResize(){
    camera.aspect = window.innerWidth / window.innerHeight;

    camera.updateProjectMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

//Add the event listener to the init() function right above the animate() call.
//The canvas will now resize with the window.
function init (){
    ...
    window.eddEventListener('resize', onWindowResize, false);
    animate();
}
